---
alwaysApply: true
---

# Aster Finance API Integration Rules

## Project Overview
This is a cryptocurrency trading platform that integrates with Aster Finance APIs for real-time market data, trading execution, and portfolio management. The project follows a multi-agent architecture using LangGraph for trading decisions.

## Technology Stack
- **Backend**: FastAPI, Python 3.11+, SQLAlchemy, Alembic
- **Frontend**: React, TypeScript, Tailwind CSS, Vite
- **Trading**: Aster Finance API (Spot & Futures), LangGraph agents
- **Database**: PostgreSQL with Alembic migrations
- **Package Management**: `uv` (Python), `pnpm` (Node.js)
- **Code Quality**: Ruff, mypy, pre-commit hooks

## Aster Finance API Integration Rules

### API Client Configuration
- **Base URLs**:
  - Spot API: `https://api.aster.finance`
  - Futures API: `https://fapi.aster.finance`
  - WebSocket: `wss://stream.aster.finance`
- **Authentication**: Use API keys with proper signature generation
- **Rate Limits**: Implement exponential backoff for rate limit handling
- **Error Handling**: Always handle API errors gracefully with specific exception types

### Required Dependencies
```python
# Add to pyproject.toml
aster-connector-python = { git = "https://github.com/asterdex/aster-connector-python.git" }
requests = "^2.31.0"
websockets = "^11.0.0"
```

### Service Architecture Patterns
- **AsterService**: Central service for Aster API interactions
- **MarketDataService**: Real-time price feeds and market data
- **TradingService**: Order execution and portfolio management
- **WebSocketService**: Real-time data streaming

### Code Organization
- Place Aster-specific tools in `app/backend/src/tools/aster/`
- Create service classes following OOP patterns
- Use dependency injection for configuration
- Implement proper error handling and logging

## Service Implementation Pattern
```python
class AsterMarketDataService:
    """
    Service for fetching market data from Aster Finance API.
    """

    def __init__(self, api_key: str, secret_key: str, base_url: str):
        self.api_key = api_key
        self.secret_key = secret_key
        self.base_url = base_url
        self.session = aiohttp.ClientSession()

    async def afetch_klines(self, symbol: str, interval: str, limit: int = 500) -> list[dict]:
        """
        Fetch kline/candlestick data for a symbol.

        Parameters
        ----------
        symbol : str
            Trading pair symbol.
        interval : str
            Kline interval.
        limit : int
            Number of klines to retrieve.

        Returns
        -------
        list[dict]
            List of kline data dictionaries.
        """
        # Implementation here
        pass

    async def aclose(self):
        """Close the HTTP session."""
        await self.session.close()
```

## Error Handling
```python
class AsterAPIError(Exception):
    """Base exception for Aster API errors."""
    pass

class RateLimitError(AsterAPIError):
    """Raised when API rate limit is exceeded."""
    pass

class AuthenticationError(AsterAPIError):
    """Raised when API authentication fails."""
    pass
```

## Database Integration

### Alembic Migration Naming
- Follow pattern: `000x_description.py` (e.g., `0011_add_aster_trading_tables.py`)
- Create tables for Aster-specific data:
  - `aster_api_keys`: Store API credentials
  - `aster_trades`: Trade execution records
  - `aster_positions`: Position tracking
  - `aster_market_data`: Cached market data

### Model Examples
```python
class AsterAPIKey(Base):
    __tablename__ = "aster_api_keys"

    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    api_key = Column(String(255), nullable=False)
    secret_key = Column(String(255), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime, default=datetime.utcnow)
```

## Testing Requirements

### Unit Tests
- Test all Aster service methods with mocked responses
- Test error handling scenarios (rate limits, auth failures)
- Test WebSocket connection handling
- Aim for 90%+ test coverage

### Integration Tests
- Test real API calls in `tests/backtesting/integration/`
- Use test API keys for integration testing
- Test trading workflows end-to-end

### Test Structure
```python
# tests/test_aster_services.py
import pytest
from unittest.mock import AsyncMock, patch
from app.backend.services.aster_service import AsterMarketDataService

class TestAsterMarketDataService:
    @pytest.fixture
    def service(self):
        return AsterMarketDataService("test_key", "test_secret", "https://test.api")

    @pytest.mark.asyncio
    async def test_fetch_klines_success(self, service):
        # Test implementation
        pass

    @pytest.mark.asyncio
    async def test_fetch_klines_rate_limit(self, service):
        # Test rate limit handling
        pass
```

## Frontend Integration

### React Components
- Create `AsterMarketData` component for real-time price displays
- Implement `TradingInterface` for order placement
- Use WebSocket hooks for real-time updates
- Follow the "Mythic Futurism" design system

### WebSocket Integration
```typescript
// hooks/useAsterWebSocket.ts
import { useEffect, useState } from 'react';

export const useAsterWebSocket = (symbol: string) => {
  const [price, setPrice] = useState<number | null>(null);
  const [isConnected, setIsConnected] = useState(false);

  useEffect(() => {
    // WebSocket implementation
  }, [symbol]);

  return { price, isConnected };
};
```

## Security Guidelines

### API Key Management
- Never commit API keys to version control
- Use environment variables for configuration
- Implement key rotation mechanisms
- Store encrypted keys in database

### Rate Limiting
- Implement client-side rate limiting
- Use exponential backoff for retries
- Monitor API usage and implement alerts

## Performance Optimization

### Caching Strategy
- Cache market data in Redis
- Implement TTL-based cache invalidation
- Use background tasks for data updates

### Async Operations
- Use `asyncio` for concurrent API calls
- Implement connection pooling
- Use `aiohttp` for HTTP requests

## Common Patterns

### Error Handling
```python
try:
    data = await aster_service.afetch_market_data(symbol)
except RateLimitError:
    await asyncio.sleep(60)  # Wait before retry
    data = await aster_service.afetch_market_data(symbol)
except AuthenticationError:
    logger.error("API authentication failed")
    raise
except Exception as e:
    logger.error(f"Unexpected error: {e}")
    raise AsterAPIError(f"Failed to fetch market data: {e}")
```

### Configuration Management
```python
# config/aster.py
from pydantic import BaseSettings

class AsterConfig(BaseSettings):
    api_key: str
    secret_key: str
    base_url: str = "https://api.aster.finance"
    futures_url: str = "https://fapi.aster.finance"
    websocket_url: str = "wss://stream.aster.finance"

    class Config:
        env_file = ".env"
```

## Environment Variables
```bash
# .env.example
ASTER_API_KEY=your_api_key_here
ASTER_SECRET_KEY=your_secret_key_here
ASTER_BASE_URL=https://api.aster.finance
ASTER_FUTURES_URL=https://fapi.aster.finance
ASTER_WEBSOCKET_URL=wss://stream.aster.finance
```

## Monitoring and Logging

### Logging Standards
```python
import logging

logger = logging.getLogger(__name__)

# Log API calls
logger.info(f"Fetching market data for {symbol}")
logger.error(f"API call failed: {error}")
logger.warning(f"Rate limit exceeded, retrying in {delay}s")
```

### Metrics Collection
- Track API response times
- Monitor rate limit usage
- Log trading performance metrics
- Implement alerting for failures

## Best Practices

1. **Always use async/await** for I/O operations
2. **Implement proper error handling** with specific exception types
3. **Use dependency injection** for configuration
4. **Follow the service layer pattern** for business logic
5. **Write comprehensive tests** for all functionality
6. **Use type hints** throughout the codebase
7. **Implement proper logging** for debugging and monitoring
8. **Follow security best practices** for API key management
9. **Use caching** to reduce API calls and improve performance
10. **Document everything** with clear docstrings and comments

## Common Anti-Patterns to Avoid

1. **Don't use global configurations** - use dependency injection
2. **Don't ignore API rate limits** - implement proper handling
3. **Don't commit API keys** - use environment variables
4. **Don't use blocking I/O** - use async/await
5. **Don't skip error handling** - always handle exceptions
6. **Don't use bare except clauses** - be specific about exceptions
7. **Don't skip tests** - maintain high test coverage
8. **Don't use outdated patterns** - follow modern Python practices
